import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o,c as d,e as s,a as l,d as a,w as r,b as i,f as h}from"./app-d6438571.js";const c={},u=l("p",null,[i("架构目标：快速响应，高可用，可升缩，可扩展，安全性，敏捷开发。"),l("br"),l("img",{src:"https://s3.ax1x.com/2021/01/22/sIFyNT.png",alt:"架构目标",loading:"lazy"})],-1),_={class:"table-of-contents"},p=h('<h2 id="架构策略" tabindex="-1"><a class="header-anchor" href="#架构策略" aria-hidden="true">#</a> 架构策略</h2><ul><li>分层：分层拆分（表现层，业务层，持久层）</li><li>分割：连接池分割，机房，进程（分布式）</li><li>分布式：分布式架构</li><li>集群： 高可用</li><li>缓存： 堆内存缓存，redis 缓存，lua 缓存</li><li>异步： 写异步</li><li>冗余： 数据库设计，读，写</li><li>安全： 数据安全（加密）、系统安全</li><li>自动： 运维，扩容，缩容；</li><li>敏捷： 可持续集成，交付，部署<br><img src="https://s3.ax1x.com/2021/01/22/sIF0un.png" alt="架构策略" loading="lazy"></li></ul><h2 id="解决高可用问题方案" tabindex="-1"><a class="header-anchor" href="#解决高可用问题方案" aria-hidden="true">#</a> 解决高可用问题方案</h2><ol><li><p>负载均衡<br><br> 七层的负载均衡一般是：DNS 或者 nginx 负载均衡<br><br> 负载均衡算法：<br> - round-robin： 轮询，默认负载均衡算法。通过配合 weight 配置可以实现基于权重的轮询 - ip_hash ：根据客户 IP 进行负载均衡，即相同的 IP 将负载均衡到同一个 server。 - hash key [consistent]： 对某一个 key 进行哈希或者使用一致性哈希算法进行负载均衡。</p></li><li><p>限流<br><br> 限流算法：漏桶算法，令牌桶算法。<br><br> 常规的做法：Tomcat 限流，接口限流，redis 限流（Redis+lua），nginx 限流</p></li><li><p>降级<br><br> 降级的最终目的是保证核心服务可用，即使是有损的。<br><br> 降级也需要根据系统的吞吐量. 响应时间. 可用率等条件进行手工降级或自动降级。</p></li><li><p>隔离<br><br> 资源隔离通过隔离来减少资源竞争，保障服务间的相互不影响和可用性。<br><br> 在实际生产环境中，比较多的隔离手段有线程隔离. 进程隔离. 集群隔离. 机房隔离. 读写隔离. 快慢隔离. 动静隔离等。</p></li><li><p>超时与重试<br></p></li><li><p>回滚<br></p></li><li><p>压测与预案<br><br> 压测一般指性能压力测试，用来评估系统的稳定性和性能，通过压测数据进行系统容量评估，从而决定是否需要进行扩容或缩容。</p></li></ol><h2 id="列举一些压测方案" tabindex="-1"><a class="header-anchor" href="#列举一些压测方案" aria-hidden="true">#</a> 列举一些压测方案</h2><ul><li>压测接口</li><li>并发量</li><li>压测策略（突发. 逐步加压. 并发量）</li><li>压测指标（机器负载. QPS/TPS. 响应时间[平均. 最小. 最大]）</li></ul><h2 id="什么是高并发" tabindex="-1"><a class="header-anchor" href="#什么是高并发" aria-hidden="true">#</a> 什么是高并发</h2><p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p><p>高并发相关常用的一些指标</p><ul><li>响应时间（Response Time）</li><li>吞吐量（Throughput） : 单位时间内处理的请求数量（并发数量）。在大多数情况系下，qps = tps = 吞吐量</li><li>QPS ：每秒响应请求数。在互联网领域，这个指标和吞吐量区分的没有这么明显。</li><li>TPS ：每秒事务数量, 一个接口请求从发送请求到接收到响应为止，代表一个 tps。</li><li>并发用户数 ：同时承载正常使用系统功能的用户数量。</li></ul><h2 id="如何保障系统的高并发" tabindex="-1"><a class="header-anchor" href="#如何保障系统的高并发" aria-hidden="true">#</a> 如何保障系统的高并发？</h2><ol><li>服务尽量进行拆分部署（分布式：SOA,微服务）; --- 业务纵向拆分，化整为零，资源拆分，横向扩展</li><li>尽量将请求拦截在系统上游（越上游越好）; --- 限流，缓存</li><li>读多写少多使用缓存（缓存抗读压力）; --- 读缓存，写异步</li><li>浏览器和 APP：做限速（漏桶原理） --- 限速，限流</li><li>站点层：按照 uid 做限速，做页面缓存</li><li>服务层：按照业务做写请求队列控制流量，做数据缓存 – 队列缓冲</li><li>数据层：压力就小了，无忧无虑 –-数据库优化</li><li>其他方面：结合业务做优化</li></ol><p>具体的解决方案：缓存（应用级别缓存. http 缓存. 多级缓存）,连接池,异步,扩容,队列</p><h2 id="数据层高并发优化" tabindex="-1"><a class="header-anchor" href="#数据层高并发优化" aria-hidden="true">#</a> 数据层高并发优化</h2><ul><li>数据库优化：--- RT --- 吞吐量 <ol><li>集群（分表. 分库. 读写分离【解决读压力】）</li><li>索引</li><li>开启缓存</li><li>SQL 优化</li><li>冗余设计</li><li>防止写复杂 SQL</li><li>冷热数据分离</li></ol></li><li>分布式文件系统： <ol><li>开源文件系统 FastDFS</li><li>云服务<br> 日志数据/搜索数据/简单业务数据<br> elasticSearch / Redis 缓存</li></ol></li></ul><h2 id="应用层高并发优化" tabindex="-1"><a class="header-anchor" href="#应用层高并发优化" aria-hidden="true">#</a> 应用层高并发优化</h2><ol><li>web 服务器优化 （线程池，连接队列）</li><li>JVM 优化</li><li>代码结构优化（code review）</li><li>分布式拆分（提高吞吐量，提高集群部署网络数量）</li><li>异步架构</li><li>异步并发编程</li><li>队列 ：缓冲队列，让你无队列，消息队列</li><li>线程池</li><li>nosql</li></ol><h2 id="前端高并发优化" tabindex="-1"><a class="header-anchor" href="#前端高并发优化" aria-hidden="true">#</a> 前端高并发优化</h2><ol><li>DNS 缓存</li><li>CDN 缓存</li><li>浏览器缓存</li><li>nginx 缓存</li></ol>',19);function b(f,x){const e=n("router-link");return o(),d("div",null,[u,s(" more "),l("nav",_,[l("ul",null,[l("li",null,[a(e,{to:"#架构策略"},{default:r(()=>[i("架构策略")]),_:1})]),l("li",null,[a(e,{to:"#解决高可用问题方案"},{default:r(()=>[i("解决高可用问题方案")]),_:1})]),l("li",null,[a(e,{to:"#列举一些压测方案"},{default:r(()=>[i("列举一些压测方案")]),_:1})]),l("li",null,[a(e,{to:"#什么是高并发"},{default:r(()=>[i("什么是高并发")]),_:1})]),l("li",null,[a(e,{to:"#如何保障系统的高并发"},{default:r(()=>[i("如何保障系统的高并发？")]),_:1})]),l("li",null,[a(e,{to:"#数据层高并发优化"},{default:r(()=>[i("数据层高并发优化")]),_:1})]),l("li",null,[a(e,{to:"#应用层高并发优化"},{default:r(()=>[i("应用层高并发优化")]),_:1})]),l("li",null,[a(e,{to:"#前端高并发优化"},{default:r(()=>[i("前端高并发优化")]),_:1})])])]),p])}const S=t(c,[["render",b],["__file","10.高并发_高可用系统.html.vue"]]);export{S as default};
