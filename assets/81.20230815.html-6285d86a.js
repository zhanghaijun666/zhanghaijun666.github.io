import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as h,f as i}from"./app-d6438571.js";const d={},r=i('<h2 id="_1、redis-的单机、哨兵、集群的区别和选型" tabindex="-1"><a class="header-anchor" href="#_1、redis-的单机、哨兵、集群的区别和选型" aria-hidden="true">#</a> 1、Redis 的单机、哨兵、集群的区别和选型？</h2><h3 id="单机模式" tabindex="-1"><a class="header-anchor" href="#单机模式" aria-hidden="true">#</a> 单机模式</h3><blockquote><p>在单机模式下，Redis 运行在单个实例上，所有的数据都存储在这一个实例中。优点包括部署简单、操作方便，适用于快速的数据缓存需求。</p></blockquote><ul><li>缺点 <ul><li>单点故障：如果 Redis 实例出现故障，数据可能会丢失。</li><li>有限的容量：内存容量受到物理服务器的限制。</li><li>不支持高可用性：无法提供自动故障转移或负载均衡。</li></ul></li></ul><h3 id="哨兵模式" tabindex="-1"><a class="header-anchor" href="#哨兵模式" aria-hidden="true">#</a> 哨兵模式</h3><blockquote><p>哨兵部署在单机部署的基础上，引入了哨兵节点，用于监控主节点的健康状态，并在主节点故障时自动进行切换。</p><p>哨兵模式提供了一定程度的高可用性，但不支持数据分片。</p></blockquote><ul><li>自动故障转移：当主节点出现问题时，哨兵节点会选举一个新的主节点，确保系统可用。</li><li>有限的扩展性：虽然可以通过增加哨兵节点来提高可用性，但在数据量和性能方面有限制。</li></ul><h3 id="集群模式" tabindex="-1"><a class="header-anchor" href="#集群模式" aria-hidden="true">#</a> 集群模式</h3><blockquote><p>集群部署适用于需要高性能和高可用性的大规模应用。在集群模式下，数据被分片存储在多个节点上，每个节点负责管理一部分数据。</p><p>这种方式可以水平扩展，支持更大的数据集和更高的吞吐量。</p><p>哨兵节点的数量建议是奇数，在主节点出现故障时，可以确保达成多数决策，以选择新的主节点。</p></blockquote><ul><li>数据分片：数据被均匀分布在多个节点上，可以充分利用多台服务器的资源。</li><li>自动分片和负载均衡：数据分片和负载均衡由集群自动管理，无需手动干预。</li><li>高可用性：集群中的节点可以自动进行故障转移，确保系统可用性。</li><li>部署复杂：配置和维护集群需要一些额外的工作，包括节点的添加和删除、数据迁移等。</li></ul><h2 id="redis-的数据结构和应用场景" tabindex="-1"><a class="header-anchor" href="#redis-的数据结构和应用场景" aria-hidden="true">#</a> Redis 的数据结构和应用场景</h2><h2 id="redis-做数据库缓存-怎么解决双写的问题-是否有脏数据" tabindex="-1"><a class="header-anchor" href="#redis-做数据库缓存-怎么解决双写的问题-是否有脏数据" aria-hidden="true">#</a> Redis 做数据库缓存，怎么解决双写的问题，是否有脏数据？</h2><h2 id="mysql-默认的事务隔离机制" tabindex="-1"><a class="header-anchor" href="#mysql-默认的事务隔离机制" aria-hidden="true">#</a> MySQL 默认的事务隔离机制</h2><h2 id="mysql-执行-updaye-是怎么执行的" tabindex="-1"><a class="header-anchor" href="#mysql-执行-updaye-是怎么执行的" aria-hidden="true">#</a> MySQL 执行 UPDAYE 是怎么执行的？</h2><h2 id="hashmap-是现场不安全的-满足线程安全应该怎么处理" tabindex="-1"><a class="header-anchor" href="#hashmap-是现场不安全的-满足线程安全应该怎么处理" aria-hidden="true">#</a> HashMap 是现场不安全的，满足线程安全应该怎么处理？</h2><h2 id="executors-newcachedthreadpool" tabindex="-1"><a class="header-anchor" href="#executors-newcachedthreadpool" aria-hidden="true">#</a> Executors.newCachedThreadPool()</h2><h2 id="集成方案提供技术支持-典型的案例" tabindex="-1"><a class="header-anchor" href="#集成方案提供技术支持-典型的案例" aria-hidden="true">#</a> 集成方案提供技术支持，典型的案例？</h2><h2 id="高可用的部署方案" tabindex="-1"><a class="header-anchor" href="#高可用的部署方案" aria-hidden="true">#</a> 高可用的部署方案？</h2>',18),l=[r];function s(t,c){return a(),h("div",null,l)}const u=e(d,[["render",s],["__file","81.20230815.html.vue"]]);export{u as default};
