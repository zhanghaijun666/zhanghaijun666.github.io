import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as p,c,e as o,a as s,d as e,w as l,b as n,f as r}from"./app-d6438571.js";const d={},k={class:"table-of-contents"},u=s("p",null,"按照锁的粒度来说，MySQL 主要包含三种类型（级别）的锁定机制：",-1),m=s("ul",null,[s("li",null,"全局锁：锁的是整个 database。由 MySQL 的 SQL layer 层实现的"),s("li",null,"表级锁：锁的是某个 table。由 MySQL 的 SQL layer 层实现的"),s("li",null,[n("行级锁：锁的是某行数据，也可能锁定行之间的间隙。由某些存储引擎实现，比如 InnoDB。"),s("br"),n(" 按照锁的功能来说分为：共享锁和排他锁。")])],-1),b=s("p",null,"死锁：有两个或两个以上的资源的情况下，有两个事物互相持有了对方期待的资源，导致互相等待对方释放资源时，产生死锁。",-1),v=r(`<h2 id="全局锁" tabindex="-1"><a class="header-anchor" href="#全局锁" aria-hidden="true">#</a> 全局锁</h2><p>加全局锁，会导致数据库变成只读状态，一般不建议使用。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 加全局锁的命令</span>
flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span><span class="token punctuation">;</span>
<span class="token comment">-- 释放全局锁，或者会话关闭，锁自动解除。</span>
<span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mysql-表级锁" tabindex="-1"><a class="header-anchor" href="#mysql-表级锁" aria-hidden="true">#</a> MySQL 表级锁</h2><ul><li><p>表读、写锁。 <br><br> 表锁一般也不经常使用，粒度比较粗。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看表级锁定的争用状态变量</span>
<span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">&#39;table%&#39;</span><span class="token punctuation">;</span>
<span class="token comment">-- table_locks_immediate：产生表级锁定的次数;</span>
<span class="token comment">-- table_locks_waited：出现表级锁定争用而发生等待的次数;</span>

<span class="token comment">-- 手动增加表锁</span>
<span class="token keyword">lock</span> <span class="token keyword">table</span> 表名称 <span class="token keyword">read</span><span class="token punctuation">(</span><span class="token keyword">write</span><span class="token punctuation">)</span><span class="token punctuation">,</span>表名称<span class="token number">2</span> <span class="token keyword">read</span><span class="token punctuation">(</span><span class="token keyword">write</span><span class="token punctuation">)</span>，其他<span class="token punctuation">;</span>
<span class="token comment">-- 查看表锁情况</span>
<span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
<span class="token comment">-- 删除表锁</span>
<span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>元数据锁（meta data lock，MDL)。 <br><br> 当事务未结束时，在事务中执行了 select 操作，不允许对表结构进行修改的。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- （session1）开启事务</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token comment">-- （session1）加MDL读锁</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> users<span class="token punctuation">;</span>
<span class="token comment">-- （session2）新开一个窗口，执行修改语句，会被阻塞，知道前面的事务释放</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> users <span class="token keyword">add</span> age <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token comment">-- （session1）提交或者回滚（rollback）事务</span>
<span class="token keyword">commit</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>自增锁(AUTO-INC Locks)。<br><br> AUTO-INC 锁是一种特殊的表级锁，发生涉及 AUTO_INCREMENT 列的事务性插入操作时产生。</p></li></ul><h2 id="innodb-的行锁" tabindex="-1"><a class="header-anchor" href="#innodb-的行锁" aria-hidden="true">#</a> InnoDB 的行锁</h2><ul><li><p>记录锁（Record Locks）<br><br> 锁定索引中一条记录。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 加共享锁：</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token comment">-- 加排它锁：</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>意向锁（Intention Locks）<br><br> 就是一个标志位，为了快速判断表上是否有行锁。<br><br> 意向锁是表级锁。是<code>InnoDB</code>实现的，是行锁的一个副产品。<br></p><ul><li>意向锁共享锁 IS：表中某个记录上有共享锁是添加。<br></li><li>意向排他锁 IX：表中某个记录有排他锁是添加。<br></li></ul></li><li><p>间隙锁（Gap Locks）<br><br> 区间锁, 仅仅锁住一个索引区间（开区间，不包括双端端点）<br><br> 间隙锁可用于防止<code>幻读</code>，保证索引间的不会被插入数据。 <br></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- session1:</span>
<span class="token keyword">begin</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1_simple <span class="token keyword">where</span> id <span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token comment">---------------------------------------------------------</span>
<span class="token comment">-- session2:</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t1_simple <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">--阻塞</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t1_simple <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">--成功</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>临键锁（Next-Key Locks）<br><br> 是索引记录上的记录锁和在索引记录之前的间隙锁的组合（间隙锁+记录 锁）。</p><ul><li>记录锁：条件中根据主键等值查询，并且值存在时，只有记录锁。</li><li>间隙锁：条件中根据主键等值查询，并且值不存在时，只有间隙锁，锁等值所在的那个区间。</li><li>临键锁：条件中根据索引做范围查询，使用临键锁。</li></ul></li><li><p>插入意向锁(Insert Intention Locks)<br><br> 做 insert 操作时添加的对记录 id 的锁。</p></li></ul><h2 id="锁相关参数" tabindex="-1"><a class="header-anchor" href="#锁相关参数" aria-hidden="true">#</a> 锁相关参数</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">&#39;innodb_row_lock%&#39;</span><span class="token punctuation">;</span>
<span class="token comment">-- Innodb_row_lock_current_waits：当前正在等待锁定的数量；</span>
<span class="token comment">-- Innodb_row_lock_time：从系统启动到现在锁定总时间长度；</span>
<span class="token comment">-- Innodb_row_lock_time_avg：每次等待所花平均时间；</span>
<span class="token comment">-- Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</span>
<span class="token comment">-- Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</span>

<span class="token comment">-- 查看事务、锁的sql</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>innodb_locks<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>innodb_lock_waits<span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> information_schema<span class="token punctuation">.</span>innodb_trx<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="行锁分析实战" tabindex="-1"><a class="header-anchor" href="#行锁分析实战" aria-hidden="true">#</a> 行锁分析实战</h2><ol><li><code>select * from t1 where id = 10</code>，这个 SQL 加什么锁？<br> 答：因为 MySQL 是使用多版本并发控制的，读不加锁。</li><li><code>delete from t1 where id = 10</code>，这个 SQL 加什么锁？ <ul><li>组合一：id 列是主键，RC 隔离级别<br><br> 答：id 是主键时，此 SQL 只需要在 id=10 这条记录上加 X 锁即可。</li><li>组合二：id 列是二级唯一索引（unique），RC 隔离级别 <br><br> 答：加两个 X 锁，一个对应于 id unique 索引上的 id = 10 的记录，另一把锁对应于聚簇索引上的【name=’d’,id=10】的记录。</li><li>组合三：id 列是二级非唯一索引，RC 隔离级别 <br><br> 答：对应的所有满足 SQL 查询条件的记录，都会被加锁。同时，这些记录在主键 索引上的记录，也会被加锁。</li><li>组合四：id 列上没有索引，RC 隔离级别 <br><br> 答：若 id 列上没有索引，SQL 会走聚簇索引的全扫描进行过滤，由于过滤是由 MySQL Server 层面进行的。因此每条记录，无论是否满足条件，都会被加上 X 锁。但是，为了效率考量，MySQL 做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了 2PL 的约束。</li><li>组合五：id 列是主键，RR 隔离级别 （组合一一致）<br><br> 答：id 是主键时，此 SQL 只需要在 id=10 这条记录上加 X 锁即可。</li><li>组合六：id 列是二级唯一索引，RR 隔离级别 <br><br> 答：两个 X 锁，id 唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个</li><li>组合七：id 列是二级非唯一索引，RR 隔离级别 <br><br> 答：首先，通过 id 索引定位到第一条满足查询条件的记录，加记录上的 X 锁，加 GAP 上的 GAP 锁，然后 加主键聚簇索引上的记录 X 锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记 录[11,f]，此时，不需要加记录 X 锁，但是仍旧需要加 GAP 锁，最后返回结束。</li><li>组合八：id 列上没有索引，RR 隔离级别 <br><br> 答：如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁 上聚簇索引内的所有 GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发 semi- consistent read，来缓解加锁开销与并发影响，但是 semi-consistent read 本身也会带来其他问 题，不建议使用</li></ul></li></ol>`,11);function w(y,_){const a=i("router-link");return p(),c("div",null,[o(" more "),s("nav",k,[s("ul",null,[s("li",null,[e(a,{to:"#全局锁"},{default:l(()=>[n("全局锁")]),_:1})]),s("li",null,[e(a,{to:"#mysql-表级锁"},{default:l(()=>[n("MySQL 表级锁")]),_:1})]),s("li",null,[e(a,{to:"#innodb-的行锁"},{default:l(()=>[n("InnoDB 的行锁")]),_:1})]),s("li",null,[e(a,{to:"#锁相关参数"},{default:l(()=>[n("锁相关参数")]),_:1})]),s("li",null,[e(a,{to:"#行锁分析实战"},{default:l(()=>[n("行锁分析实战")]),_:1})])])]),u,m,b,o(" more "),v])}const g=t(d,[["render",w],["__file","15.MySQL锁.html.vue"]]);export{g as default};
