import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as t,c as p,e as c,a as l,d as e,w as i,f as r,b as n}from"./app-d6438571.js";const u={},d={class:"table-of-contents"},b=r(`<h2 id="jvm-调优本质和原则" tabindex="-1"><a class="header-anchor" href="#jvm-调优本质和原则" aria-hidden="true">#</a> JVM 调优本质和原则</h2><ul><li>JVM 调优本质就是 gc , 垃圾回收，及时释放内存空间</li><li>gc 的时间足够小（堆内存设置足够小）</li><li>gc 的次数足够少（jvm 堆内存设置的足够大）</li><li>发生 fullgc 周期足够长 （最好不发生 full gc） <ul><li>metaspace 永久代空间设置大小合理，metaspace 一旦扩容，就会发生 fullgc</li><li>老年代空间设置一个合理的大小，防止 full gc</li><li>尽量让垃圾对象在年轻代被回收（90%）</li><li>尽量防止大对象的产生，一旦大对象多了以后，就可能发生 full gc ,甚至 oom</li></ul></li></ul><h2 id="清除垃圾算法" tabindex="-1"><a class="header-anchor" href="#清除垃圾算法" aria-hidden="true">#</a> 清除垃圾算法</h2><ol><li><p><code>mark-sweep</code> [标记清楚算法]</p><ul><li>使用根可达算法找到垃圾对象，对垃圾对象进标记 （做一个标记）</li><li>对标记对象进行删除（清除）<br> 优点： 简单，高效<br> 缺点： 清除的对象都不是一个连续的空间，清除垃圾后，产生很多内存碎片；不利于后期对象内存分配，及寻址；</li></ul></li><li><p><code>copying</code> [拷贝算法]</p><ul><li>Copying 拷贝算法： 一开始就把内存控制一份为 2，分为 2 个大小相同的的内存空间，另一半空间展示空闲；</li></ul></li></ol><ul><li>选择（寻址）存活对象</li><li>把存活对象拷贝到另一半空闲空间中，且是连续的内存空间</li><li>把存储对象拷贝结束后，另一半空间中全是垃圾，直接清除另一半空间即可；<br> 优点： 简单，内存空间是连续的，不存在内存空间碎片<br> 缺点： 内存空间浪费</li></ul><ol start="3"><li><code>mark-compact</code> [标记整理（压缩）算法]</li></ol><ul><li>标记垃圾（只标记，不清除）</li><li>再次扫描内存空间（没有被标记的对象就是存活对象），找到存活对象，且把存活对象向内存一端进行移动（一端内存空间是连续的内存空间）-- 压缩，整理</li><li>当存活对象全部被移动到一端后，那么另一端全部是垃圾对象，清除即可；</li></ul><h2 id="垃圾回收器" tabindex="-1"><a class="header-anchor" href="#垃圾回收器" aria-hidden="true">#</a> 垃圾回收器</h2><figure><img src="https://s3.ax1x.com/2021/01/29/yCY9iV.png" alt="yCY9iV" tabindex="0" loading="lazy"><figcaption>yCY9iV</figcaption></figure><ul><li>Serial Serial Old , parNew CMS , Parallel Scavenge Parallel Old 都属于物理分代垃圾回收器；年轻代，老年代分别使用不同的垃圾回收器；</li><li>G1 在逻辑上进行分代的，进行在使用上非常方便，关于年轻代，老年代只需要使用一个垃圾回收器即可；</li><li>ZGC ZGC 是一款 JDK 11 中新加入的具有实验性质的低延迟垃圾收集器</li><li>Shenandoah OpenJDK 垃圾回收器</li><li>Epsilon 是 Debug 使用的，调试环境下：验证 jvm 内存参数设置的可行性</li><li>Serial Serial Old： 串行化的垃圾回收器</li><li>parNew CMS ： 并行，并发的垃圾回收器</li><li>Parallel Scavenge Parallel Old ： 并行的垃圾回收器</li></ul><p>常用的垃圾回收器组合：</p><ul><li>Serial + Serial Old: 串行化的垃圾回收器，适合单核心的 cpu 的服务情况</li><li>parNew + CMS：响应时间优先组合</li><li>Parallel Scavenge + Parallel Old ： 吞吐量优先组合</li><li>g1 ： 逻辑上分代的垃圾回收器组合</li></ul><h2 id="典型参数设置" tabindex="-1"><a class="header-anchor" href="#典型参数设置" aria-hidden="true">#</a> 典型参数设置</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">nohup</span> <span class="token function">java</span> <span class="token parameter variable">-Xmx4000m</span> <span class="token parameter variable">-Xms4000m</span> <span class="token parameter variable">-Xmn2g</span> <span class="token parameter variable">-Xss256k</span>  <span class="token parameter variable">-jar</span> jshop-web-1.0-SNAPSHOT.jar --spring.config.addition-location<span class="token operator">=</span>application.yaml <span class="token operator">&gt;</span> jshop.log <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token operator">&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>-Xmx4000m</p><blockquote><p>设置 JVM 最大堆内存（经验值：3500m – 4000m,内存设置大小，根据实际情况来进行设置的）</p></blockquote></li><li><p>-Xms4000m</p><blockquote><p>设置 JVM 堆内存初始化的值，一般情况下，初始化的值和最大堆内存值必须一致，防止内存抖动；</p></blockquote></li><li><p>-Xmn2g</p><blockquote><p>设置年轻代内存对象（eden,s1,s2）</p></blockquote></li><li><p>-XX:NewRatio = 4</p><blockquote><p>表示年轻代（eden ,s0,s1） 和老年代区域所占比值 1:4</p></blockquote></li><li><p>-Xss256k</p><blockquote><p>设置线程栈大小，JDK1.5+版本线程栈默认是 1MB, 相同的内存情况下，线程堆栈越小，操作系统创建的线程越多；</p></blockquote></li><li><p>-XX:MetaspaceSize=256m</p></li><li><p>-XX:SurvivorRatio=8</p></li><li><p>-XX:MaxTenuringThreshold</p><blockquote><p>设置的是年龄阈值，默认 15（对象被复制的次数）</p></blockquote></li><li><p>-XX:G1HeapRegionsize</p><blockquote><p>G1Region 块大小，在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。</p></blockquote></li><li><p>-XX:+PrintGCDetails</p><blockquote><p>打印 GC 详细信息</p></blockquote></li><li><p>-XX:+PrintGCTimeStamps</p><blockquote><p>打印 GC 时间信息</p></blockquote></li><li><p>-XX:+PrintGCDateStamps</p><blockquote><p>打印 GC 日期的信息</p></blockquote></li><li><p>-XX:+PrintHeapAtGC</p><blockquote><p>打印 GC 堆内存信息</p></blockquote></li><li><p>-Xloggc:gc.log</p><blockquote><p>把 gc 信息输出 gc.log 文件中</p></blockquote></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>问题： 根据什么标准判断参数设置是否合理呢？？ 根据什么指标进行调优呢？？
 <span class="token number">1</span>、发生几次gc, 是否频繁的发送gc??
 <span class="token number">2</span>、是否发生fullgc ,full gc发生是否合理
 <span class="token number">3</span>、gc的时间是否合理
 <span class="token number">4</span>、oom

GC日志分析： 使用<span class="token punctuation">[</span>https://gceasy.io<span class="token punctuation">]</span><span class="token punctuation">(</span>https://gceasy.io<span class="token punctuation">)</span> 导入gc.log 进行在线分析即可<span class="token punctuation">;</span>

<span class="token comment"># 查询此进程的gc内存模型；</span>
jstat <span class="token parameter variable">-gcutil</span>  PID
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gc-组合" tabindex="-1"><a class="header-anchor" href="#gc-组合" aria-hidden="true">#</a> GC 组合</h2><ol><li>吞吐量优先</li></ol><blockquote><p>并行的垃圾回收器： parallel scavenge(年轻代) + parallel old（老年代） ---- 是 JDK 默认的垃圾回收器<br> 显式的配置 PS+PO 垃圾回收器：<strong>-XX:+UseParallelGC -XX:+UseParallelOldGC</strong></p></blockquote><ol start="2"><li>响应时间优先</li></ol><blockquote><p>并行垃圾回收器（年轻代），并发垃圾回收器(老年代) ： ParNew + CMS (响应时间优先垃圾回收器)<br> 显式配置：parNew+CMS 垃圾回收器组合：<strong>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</strong><br> 说明： CMS 只有再发生 fullgc 的时候才起到作用，CMS 一般情况下不会发生；因此在 jvm 调优原则中表示尽量防止发生 fullgc;<br> 因此 CMS 在 JDK14 被已经被废弃；</p></blockquote><ol start="3"><li>G1</li></ol><blockquote><p>G1 垃圾回收器是逻辑上分代模型，使用配置简单<br> -XX:+UseG1GC<br> 经过测试，发现 g1 gc 次数减少，由原来的 28 次减少为 21 次，但是 gc 总时长增加很多；时间增加，以为着服务性能就没有提升上去</p></blockquote>`,23);function m(g,k){const a=o("router-link");return t(),p("div",null,[c(" more "),l("nav",d,[l("ul",null,[l("li",null,[e(a,{to:"#jvm-调优本质和原则"},{default:i(()=>[n("JVM 调优本质和原则")]),_:1})]),l("li",null,[e(a,{to:"#清除垃圾算法"},{default:i(()=>[n("清除垃圾算法")]),_:1})]),l("li",null,[e(a,{to:"#垃圾回收器"},{default:i(()=>[n("垃圾回收器")]),_:1})]),l("li",null,[e(a,{to:"#典型参数设置"},{default:i(()=>[n("典型参数设置")]),_:1})]),l("li",null,[e(a,{to:"#gc-组合"},{default:i(()=>[n("GC 组合")]),_:1})])])]),b])}const f=s(u,[["render",m],["__file","20.JVM调优.html.vue"]]);export{f as default};
