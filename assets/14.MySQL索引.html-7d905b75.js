import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as d,c as r,e as t,a as n,d as a,w as l,b as s,f as o}from"./app-d6438571.js";const u={},k={class:"table-of-contents"},m=n("p",null,[s("索引：是帮助 MySQL"),n("code",null,"高效获取数据"),s("的"),n("code",null,"数据结构"),s("，一般默认都是使用 B+树结构组织的索引。")],-1),v=o(`<h2 id="索引的类型" tabindex="-1"><a class="header-anchor" href="#索引的类型" aria-hidden="true">#</a> 索引的类型</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 主键索引：索引列中的值必须是唯一的，不允许有空值。</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 唯一索引：索引列中的值必须是唯一的，但是允许为空值。</span>
<span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> <span class="token keyword">table</span><span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 创建全文索引（很少使用），只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>t_fulltext<span class="token punctuation">\`</span></span> <span class="token keyword">ADD</span> FULLTEXT <span class="token keyword">INDEX</span> <span class="token identifier"><span class="token punctuation">\`</span>idx_content<span class="token punctuation">\`</span></span><span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>content<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 前缀索引（很少使用），指定索引列的长度，但是数值类型不能指定</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>column1<span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 组合索引的使用，需要遵循最左前缀原则。</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">INDEX</span> index_name <span class="token punctuation">(</span>column1<span class="token punctuation">,</span>column2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 删除索引</span>
<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> <span class="token keyword">table</span><span class="token punctuation">;</span>
<span class="token comment">-- 查看索引</span>
<span class="token keyword">SHOW</span> <span class="token keyword">INDEX</span> <span class="token keyword">FROM</span> table_name \\G<span class="token punctuation">;</span>
<span class="token comment">-- 查看索引 B+树的高度</span>
<span class="token keyword">SELECT</span> b<span class="token punctuation">.</span>name<span class="token punctuation">,</span> a<span class="token punctuation">.</span>name<span class="token punctuation">,</span> index_id<span class="token punctuation">,</span> <span class="token keyword">type</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>space <span class="token punctuation">,</span> a<span class="token punctuation">.</span>PAGE_NO <span class="token keyword">FROM</span> information_schema<span class="token punctuation">.</span>INNODB_SYS_INDEXES a<span class="token punctuation">,</span> information_schema<span class="token punctuation">.</span>INNODB_SYS_TABLES b <span class="token keyword">WHERE</span> a<span class="token punctuation">.</span>table_id <span class="token operator">=</span> b<span class="token punctuation">.</span>table_id <span class="token operator">AND</span> a<span class="token punctuation">.</span>space <span class="token operator">&lt;&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="索引的数据结构" tabindex="-1"><a class="header-anchor" href="#索引的数据结构" aria-hidden="true">#</a> 索引的数据结构</h2>`,3),b={href:"https://www.cs.usfca.edu/~galles/visualization/Algorithms.html",target:"_blank",rel:"noopener noreferrer"},h=o(`<ul><li>hash<br><br> 特点：key-value 形式的数据结构。查询速度非常快。直接通过可以找到 value。<br><br> 优点：速度快。时间复杂度 O(1)<br><br> 缺点：不适合范围查询。不适合做索引。<br></li><li>二叉查找树<br><br> 特点：左子树一定是小于根节点，右子树一定是大于根节点。时间复杂度 O(log2n)<br><br> 问题：根节点的选取最好是所有数据中中间数值。否则左子树和右子树高度可能不一致。最差情况下退化成链表。<br></li><li>二叉平衡树查找树<br><br> 特点：向树中增加节点，动态调整树的平衡状态，要求左右子树的高度相差最大不能超过 1。<br><br> 问题：不断的添加数据，二叉树会不断的调整状态。调整的过程也是非常耗时的。总体上性能也不太好。<br></li><li>B 树（多叉平衡查找树）<br><br> 特点：每个节点中都保存数据；数据出现在中间节点中，就不会出现在叶子节点中。<br><br> 问题：使用 B 树做范围查询效率不高。<br></li><li>B+树（对 B 树的改进）<br><ul><li>b+树中除叶子节点外，中间节点不保存数据，中间节点保存的是主键。</li><li>b+树中所有的数据都存放在叶子节点中。</li><li>b+树中叶子节点之间有双向指针，形成一个双向链表。</li><li>b+树适合于等值查询也适合于范围查询。在 mysql 中所有的索引都是 b+tree 结构。</li></ul></li></ul><h2 id="索引创建原则" tabindex="-1"><a class="header-anchor" href="#索引创建原则" aria-hidden="true">#</a> 索引创建原则</h2><ul><li>频繁出现在 where 条件判断，order 排序，group by 分组字段</li><li>select 频繁查询的列，考虑是否需要创建联合索引（覆盖索引，不回表）</li><li>多表 join 关联查询，on 字段两边的字段都要创建索引</li></ul><h2 id="索引优化建议" tabindex="-1"><a class="header-anchor" href="#索引优化建议" aria-hidden="true">#</a> 索引优化建议</h2><ol><li>表记录很少不需创建索引 （索引是要有存储的开销）。</li><li>一个表的索引个数不能过多。</li><li>频繁更新的字段不建议作为索引。</li><li>不建议使用区分度低的字段（比如性别）作为建索引。（仅供参考）</li><li>在 InnoDB 存储引擎中，主键索引建议使用自增的长整型，避免使用很长的字段。</li><li>不建议用无序的值作为索引。例如身份证、UUID。</li><li>尽量创建组合索引，而不是单列索引。</li></ol><h2 id="索引使用建议" tabindex="-1"><a class="header-anchor" href="#索引使用建议" aria-hidden="true">#</a> 索引使用建议</h2><ol><li>全值匹配我最爱。</li><li>最佳左前缀法则。（带头索引不能死，中间索引不能断）</li><li>不要在索引上做计算。不要进行这些操作：计算、函数、自动/手动类型转换，不然会导致索引失效而转向全表扫描。</li><li>范围条件右边的列失效。不能继续使用索引中范围条件（bettween、&lt;、&gt;、in 等）右边的列。</li><li>尽量使用覆盖索引。尽量使用覆盖索引（只查询索引的列），也就是索引列和查询列一致，减少 select *。</li><li>索引字段上不要使用不等。会导致索引失效而转向全表扫描。</li><li>索引字段上不要判断 null。会导致索引失效而转向全表扫描。</li><li>索引字段使用 like 不以通配符开头。</li><li>索引字段字符串要加单引号。索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描。</li><li>索引字段不要使用 or。会导致索引失效而转向全表扫描。</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 优化口诀</span>
全值匹配我最爱，最左前缀要遵守。
头大哥不能死，中间兄弟不能段。
索引列上少计算，范围之后全失效。
like百分写最右，覆盖索引不写*。
不等空值还有or，索引失效要少用。
字符串引号不可丢，SQL高级也不难。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="经典面试题" tabindex="-1"><a class="header-anchor" href="#经典面试题" aria-hidden="true">#</a> 经典面试题</h2><ol><li><p>InnoDB 一棵 B+树可以存放多少行数据？</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>这个问题的简单回答是：约2千万行。
-- 在计算机中，磁盘存储数据最小单元是扇区，一个扇区的大小是512字节。
-- Liunx文件系统中，最小单位是块，一个块大小默认是4k。\`getconf PAGE_SIZE\`
-- InnoDB存储引擎最小储存单元是页，一页大小默认是16k。\`show global status like &quot;Innodb_page_size&quot;\`
-- 假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，所以就是8+6=14字节，16k/14B =16*1024B/14B = 1170
-- 一棵高度为2的B+树，能存放1170 * 16=18720 条这样的数据记录
-- 同理一棵高度为3的B+树，能存放1170 *1170 *16 =21902400 条这样的数据记录
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>为什么索引结构默认使用 B+树，而不是 B-Tree，Hash 哈希，二叉树，红黑树？</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Hash哈希，只适合等值查询，不适合范围查询。
二叉树，可能会特殊化为一个链表，相当于全表扫描。
红黑树，是一种特化的平衡二叉树，MySQL 数据量很大的时候，索引的体积也会很大，内存放不下的而从磁盘读取，树的层次太高的话，读取磁盘的次数就多了。
B-Tree，叶子节点和非叶子节点都保存数据，相同的数据量，B+树更矮壮，也是就说，相同的数据量，B+树数据结构，查询磁盘的次数会更少。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>B-树和 B+树的区别</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>B-树内部节点是保存数据的;而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。
B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。
查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束
B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol>`,10);function _(w,y){const e=i("router-link"),c=i("ExternalLinkIcon");return d(),r("div",null,[t(" more "),n("nav",k,[n("ul",null,[n("li",null,[a(e,{to:"#索引的类型"},{default:l(()=>[s("索引的类型")]),_:1})]),n("li",null,[a(e,{to:"#索引的数据结构"},{default:l(()=>[s("索引的数据结构")]),_:1})]),n("li",null,[a(e,{to:"#索引创建原则"},{default:l(()=>[s("索引创建原则")]),_:1})]),n("li",null,[a(e,{to:"#索引优化建议"},{default:l(()=>[s("索引优化建议")]),_:1})]),n("li",null,[a(e,{to:"#索引使用建议"},{default:l(()=>[s("索引使用建议")]),_:1})]),n("li",null,[a(e,{to:"#经典面试题"},{default:l(()=>[s("经典面试题")]),_:1})])])]),m,t(" more "),v,n("p",null,[s("数据结构示例网站："),n("a",b,[s("https://www.cs.usfca.edu/~galles/visualization/Algorithms.html"),a(c)])]),h])}const E=p(u,[["render",_],["__file","14.MySQL索引.html.vue"]]);export{E as default};
