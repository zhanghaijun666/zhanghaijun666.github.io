import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as c,c as p,e,a as s,d as a,w as o,f as r,b as l}from"./app-d6438571.js";const d={},k={class:"table-of-contents"},u=s("p",null,"数据库事务具有 ACID 四大特性。",-1),m=s("ul",null,[s("li",null,"原子性(atomicity) ：事务最小工作单元，要么全成功，要么全失败 。"),s("li",null,"一致性(consistency)： 事务开始和结束后，数据库的完整性不会被破坏 。"),s("li",null,"隔离性(isolation) ：不同事务之间互不影响，四种隔离级别为 RU（读未提交）、RC（读已提交）、RR（可重复读）、SERIALIZABLE （串行化）。"),s("li",null,"持久性(durability) ：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失 。")],-1),b=r(`<h2 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h2><ul><li>未提交读（READ UNCOMMITTED/RU） <blockquote><p>脏读：一个事务读取到另一个事务未提交的数据，算是十分不安全的一种隔离级别</p></blockquote></li><li>已提交读（READ COMMITTED/RC） <blockquote><p>不可重复读：一个事务因读取到另一个事务已提交的 update。导致对同一条记录读取两次以上的结果不一致。</p></blockquote></li><li>可重复读（REPEATABLE READ/RR） <blockquote><p>幻读：一个事务因读取到另一个事务已提交的 insert 数据或者 delete 数据。导致对同一张表读取两次以上的结果不一致。</p></blockquote></li><li>串行化（SERIALIZABLE） <blockquote><p>以上 3 种隔离级别都允许对同一条记录进行读-读、读-写、写-读的并发操作，如果我们不允许读-写、写-读的并发操作，可以使用 SERIALIZABLE 隔离级别，</p></blockquote></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看当前事务级别：</span>
<span class="token keyword">SELECT</span> @<span class="token variable">@tx_isolation</span><span class="token punctuation">;</span>
<span class="token comment">--设置read uncommitted级别：</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置read committed级别：</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">read</span> <span class="token keyword">committed</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置repeatable read级别：</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">repeatable</span> <span class="token keyword">read</span><span class="token punctuation">;</span>
<span class="token comment">-- 设置serializable级别：</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span> <span class="token keyword">serializable</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="mvcc-多版本的并发控制" tabindex="-1"><a class="header-anchor" href="#mvcc-多版本的并发控制" aria-hidden="true">#</a> MVCC（多版本的并发控制）</h2><blockquote><p>MVCC 最大的好处：读不加锁，读写不冲突。</p><p>多版本并发控制仅仅是一种技术概念，并没有统一的实现标准， 其核心理念就是数据快照，不同的事务访问不同版本的数据快照，从而实现不同的事务隔离级别。</p></blockquote><ul><li>InnoDB 的 MVCC<br><br> MVCC 在 MySQL 中的实现依赖的是 undo log 与 read view 。</li><li>INSERT<br><br> InnoDB 为新插入的每一行保存当前事务编号作为行版本号。</li><li>DELETE<br><br> InnoDB 为删除的每一行保存当前事务编号作为行删除标识。</li><li>UPDATE<br><br> InnoDB 为插入一行新记录，保存当前事务编号作为行版本号，同时保存当前事务编号到原来的行作为行删除标识。</li></ul>`,6);function v(y,w){const n=i("router-link");return c(),p("div",null,[e(" more "),s("nav",k,[s("ul",null,[s("li",null,[a(n,{to:"#隔离级别"},{default:o(()=>[l("隔离级别")]),_:1})]),s("li",null,[a(n,{to:"#mvcc-多版本的并发控制"},{default:o(()=>[l("MVCC（多版本的并发控制）")]),_:1})])])]),u,m,e(" more "),b])}const h=t(d,[["render",v],["__file","13.MySQL事务.html.vue"]]);export{h as default};
