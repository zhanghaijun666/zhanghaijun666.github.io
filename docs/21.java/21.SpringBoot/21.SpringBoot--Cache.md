## 缓存入门

### 导入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>
```

### 开启缓存

```java
@EnableCaching
@SpringBootApplication
public class MainApplication {
    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class, args);
    }
}
```

### 常用注解

> 常用注解：`@CacheConfig`、`@Cacheable`、`@CacheEvict`、`@CachePut`、`@Caching`。

- `@CacheConfig`: 常用于类级别的注解，用于统一配置类缓存的公共属性。
- `@Caching`: 可以在一个类或方法同时使用多个缓存相关注解，灵活配置缓存策略。
- `@Cacheable`: 用于标记一个类或方法，当被标记对象被访问，会先去缓存中查询相应的结果，如果存在则返回，不存在则指向方法。
- `@CacheEvict`: 用于从缓存中移除数据。当使用`@CacheEvict`注解标记一个方法时，该方法执行后会触发缓存的清除操作。
- `@CachePut`: 用于将方法的返回值存储到缓存中。与`@Cacheable`注解不同的是，`@CachePut`注解每次都会触发方法的执行，并将结果存储到缓存中。

### 缓存示例

```java
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.text.CharSequenceUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheConfig;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import top.haijunit.work.core.doamin.PageQuery;
import top.haijunit.work.core.doamin.ResultPage;

import java.util.Collection;
import java.util.List;

/**
 * `@CacheConfig` 标记类 全局配，置避免重复配置`cacheNames`、`keyGenerator`等属性
 * `Cacheable`  标记方法，当被访问时，会先去缓存中查询相应的结果，如果存在则返回，不存在则指向方法
 * `CacheEvict` 标记方法，删除对应的缓存中的数据
 * `CachePut`   标记方法，方法执行后会触发缓存的更新操作
 */
@Slf4j
@Service
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
@CacheConfig(cacheNames = {"cache:test"})
public class CacheTestService {

    private final List<String> dataList = CollUtil.newArrayList("a", "b", "c");

    /**
     * 查询分页列表。
     * 当查询条件为空或参数长度为0时，缓存查询结果。
     */
    @Cacheable(key = "#pageQuery.getPage() + '_' + #pageQuery.getSize()", condition = "#info == null || #info.isEmpty()")
    public ResultPage<String> selectPageList(PageQuery pageQuery, String info) {
        log.info("分页查询，条件:{}, 分页: {}", info, pageQuery);
        Collection<String> list = selectList(info).stream().skip(pageQuery.offset()).limit(pageQuery.getSize()).toList();
        return ResultPage.of(list, pageQuery.getPage(), pageQuery.getSize(), list.size());
    }

    /**
     * 查询所有或根据参数过滤的数据列表。
     * 使用@Cacheable注解来缓存查询结果。
     */
    @Cacheable(key = "'list'", condition = "#dto ==null || #dto.length() == 0")
    public Collection<String> selectList(String dto) {
        log.info("查询列表，条件:{}", dto);
        if (CharSequenceUtil.isBlank(dto)) {
            return dataList;
        }
        return dataList.stream().filter(item -> CharSequenceUtil.containsAnyIgnoreCase(item, dto)).toList();
    }

    /**
     * 根据code获取详细信息。
     * 使用@Cacheable注解来缓存单个对象的详细信息。
     */
    @Cacheable(key = "#code", unless = "#result == null")
    public String selectDetail(String code) {
        log.info("查询详情，code:{}", code);
        if (CharSequenceUtil.isBlank(code)) {
            return null;
        }
        return dataList.stream().filter(item -> CharSequenceUtil.containsAnyIgnoreCase(item, code)).findFirst().orElse(null);
    }

    /**
     * 插入新数据。
     * 使用@CachePut注解来更新缓存中的值。
     */
    @CacheEvict(allEntries = true)
    public String insert(String code) {
        log.info("插入数据，code:{}", code);
        if (CharSequenceUtil.isBlank(code)) {
            return null;
        }
        if (dataList.contains(code)) {
            log.warn("插入失败，数据已存在: {}", code);
            return null;
        }
        dataList.add(code);
        return code;
    }

    /**
     * 删除数据。
     * 使用@CacheEvict注解来从缓存中移除项目。
     */
    @CacheEvict(allEntries = true)
    public String delete(String code) {
        log.info("删除数据，code:{}", code);
        if (CharSequenceUtil.isBlank(code)) {
            return null;
        }
        if (!dataList.contains(code)) {
            log.warn("删除失败，数据不存在: {}", code);
            return null;
        }
        dataList.remove(code);
        return code;
    }
}
```

## 缓存进阶

### 目标

- 1、实现两种CacheManager，本地（Caffeine）+ 远程（Redisson）。
- 2、可以通过配置`spring.cache.type`来切换本地缓存实现，可以关闭全部缓存实现。
- 3、一级缓存（本地缓存）+ 二级缓存（Redis），通过多级缓存，提高缓存的利用率。（非必须，没有想到对应的业务场景）
- 3、本地缓存和远程缓存的同步，实现数据一致性。（非必须，没有想到对应的业务场景）

### 方案实现

1. 配置`spring.cache.type`，默认使用本地缓存。
